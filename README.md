# xchsgmusic

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```

### Lints and fixes files
```
npm run lint
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).



## 在开发项目中我觉得受益匪浅的一些技巧

（欢迎指正，我也不清楚对不对，如果有改良的地方，希望不吝赐教，第一个项目需要改正的点太多了）

### 1.computed 不要在其中引用高频修改的属性值

这个是我在封装我的底部播放器时获取当前播放时长，当时会出现间断性的错误比如下一秒应该是1：33 结果又跳回了1：27 还持续显示1：27了3s，

获取当前事件的流程是：

1-1.audio触发timeupdate时使用getDuration函数，这里timeupdate平均一秒触发三次。

1-2 获取audio的currentTime属性进行加工，然后播放器中时长属性即可，

我原来是直接在audio里面直接@timeupdate = 修改data中的currentTime（未加工的时间），然后computed里面声明nowTime直接return加工完的时间，之后就出现了上述情况。后来排查原因后我直接在函数里面完成加工,nowTime也不设置为计算属性，然后这个问题就消失了。

其中我认为主要原因是**触发频率**问题。其中我设置节流定时器，限制timeupdate触发频率，然后出现数据错乱的时间点明显推迟，甚至2s一次直接没有这个问题了。但是计时这种秒级的肯定不能这样搞，

最后全排查了一遍，发现获取的原生数据没问题，然后只有加工后才出问题，这时候我又反思是不是因为我的加工逻辑写的太垃圾了导致性能不够？然后我把加工的过程省略，然后好了（又好像没好，忘记了太久以前敲的了），之后就是我说的方法，就ok了。

### 2. z-index要设置好，不然后期乱的不行

这个项目前期还好，后期包括隐藏左侧边框按钮，底部的音量按钮，搜索框，右侧边框等都用到了z-index排序，还有element-ui里面各种像loading，messagebox的幕布等，稍有不慎就会出现黑色的幕布把所有都遮住了，但是唯独没有遮住一个小按钮。

所以z-index的大小一定要有清晰的思路，而且**子级的z-index依赖于上一级定位的z-index，不是子级z-index越大就一定会在前面。所以不仅要考虑目标的z-index，还要考虑父级的z-index**。

**这里点名批评vue-scroll，这组件我再也不要用了，太折磨了，文档少的可怜，网上都是基本的教程，**

而且他的布局给我后期获取元素scrollTop等属性来置顶和适应性大小添加了不少麻烦，我下次项目一定自己写个scroll组件。

也是因为他的多层父子结构以及多层定位，我对着调试器看了一下午。它会造成如下情况

![66937761461](assets/1669377614613.png)

然后导致你在滑动音量的时候摸到滚动条，然后鼠标定位左上角直接音量100。

### 3.数据加载问题

这个是本项目最需要注意的点，起初因为我没有想出好的解决方案，开发过程中深受困扰。但其实本质很简单，也就我这么笨了（悲）。

**每个组件在created阶段需要用ajax获取接口的数据，但是由于axios请求都是异步的，那么就会导致created同步任务执行完了，接着去渲染模板了，这时候你请求的数据还没拿到，模板懵了，我数据呢？？？？。**

**正确的做法是设定isload 等待数据都加载完成了，在开始渲染你需要的模板，这样可以避免这个问题了**

```html
<template v-if="isload">
  你要渲染的内容
  <tempalte/>
```

下面是我的笨蛋方案大家不要学习，看个乐呵，如果有这个想法请立刻遏止。

法一：我设置一个定时器，等1s过后再重新渲染。但试了一会立刻驳回了。

请求数据的时间不会相同，请求大量数据需要1s甚至更多，但是一些小数据60ms就可以完成。速度慢的不能保证开始渲染模板前能拿到数据，速度快的又占用加载时间。

法二：把created设置为异步函数，await 其中包含请求的函数，等待数据都拿到了就可以继续了。

这个其实雀氏可行，但是后续加载提示等模板也不能渲染，用户不能看到加载提示，看着空白的一片还以为卡了，体验不好。其次给生命周期钩子声明成异步太怪了，本能抵触，**不知大家有没有更好的反驳理由**

### 4.点击非box区域box自动关闭

这个用于搜索框和侧边框

```js
window.addEventListener('click', (e) => {
  if (!this.$refs.footer.contains(e.target)) {
    // 如果点击的区域内不包含目标则将目标隐藏
    this.showList = false
  }
})
```

### 5.声明监听器后记得在组件beforeDestory的函数中remove

你听说了吗，调试栏中有奇怪的错误在游荡。因为他们的组件都销毁了，都没目标了肯定报错。

### 6.组件一定要细分，越细越好

**当一个功能被使用两次的时候，立刻马上把他声明称函数**，组件这种东西更夸张，有些组件可以被用好多次。这里自我反省，你可以看到我的songList组件，特别臃肿，一托答辩，

当时开发初期没想那么多，歌单面板就是SongListPanel 下面使用songList组件，后来写songList的时候虽然功能复杂，但是也还好。

后来遇到了数据类型不一样的专辑面板，每一行的展示的内容和歌单面板完全不一致，就要重新写，但这时候，包括播放，添加到我喜欢，下载，跳转面板等功能还有大量的css布局已经写到了songList中了，我承认我懒了，咬咬牙接着敲。

后来又要写右侧播放列表，还是用到了一样的布局，但是内容还不一样。所以说朋友们，提早分好组件，你把行封装成组件，那多么漂亮啊，逻辑还缜密。

所以我后期的写了特别多的组件，虽然引用会麻烦，但是真的很节省开发效率

虽然都是废话，没有知识点，但是这个对开发真的很重要。

### 7.要学会自己封装一些小组件

我在使用element-ui的时候，虽然雀氏写的很好，但是在实际开发中不能按照你的需求来，比如el-button，虽然设置了small，normal，big（好像是用的少），但是大小是锁死的，你审查元素修改他css，又会导致像文字布局中等大量其他问题，这时候为什么不自己写一个按钮呢，这次项目里我用到了大量的按钮，开始也是在组件里写样式，后来用的多了也就cv复制下，后期更不耐烦了，直接用el-button了（真香），**所以当遇到第二次使用的样式时也请立马声明组件**。

如果button你觉得封装组件不值，那起码以我的loading组件为准，这又要回到数据请求问题，每次使用的时候你都要在如下属性中写如下内容，需要重复复制多次方法，这时候一个组件可以帮你太多，还可以通过传参来设置加载时显示的内容，真的好用。

```js
data () {
  return {
    load: {
      close () {}
    }
  }
},
methods: {
  loading () {
    this.load = this.$loading({
      lock: true,
      text: this.text ? this.text : '加载中，请稍等',
      spinner: 'el-icon-loading',
      background: 'whitesmoke',
      target: document.querySelector('.' + this.coverClassName)
    })
  }
},
watch: {
  isload: {
    handler (newVal) {
      if (!newVal) {
        this.loading()
      } else {
        if (this.load !== {}) { this.load.close() }
      }
    }
  }
},
computed: {
  coverClassName () {
    return this.coverName + '-cover'
  }
},
mounted () {
  if (!this.isload) {
    this.loading()
  }
}
```

### 8.接口文档一定要仔细阅读

### 9.大量数据加载问题

### 10.弹性盒子大小

### 11.滚动加载在获取数据的过程中记得禁止接着请求数据，否则会添加重复的数据

## 目前尚未解决的问题：